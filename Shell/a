using Microsoft.Win32;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.Json;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Interop;
using System.Windows.Media;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Windows.Threading;
using Brushes = System.Windows.Media.Brushes;
using Color = System.Windows.Media.Color;
using Image = System.Windows.Controls.Image;
using Path = System.IO.Path;
using Point = System.Windows.Point;
using Rectangle = System.Windows.Shapes.Rectangle;

namespace Shell;

public partial class MainWindow : Window
{
    private readonly string _layoutFile = Path.Combine(
    Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
    "ShellDesktop",
    "layout.json");

    private class IconPosition
    {
        public double X { get; set; }
        public double Y { get; set; }
    }

    private class IconLayout
    {
        public Dictionary<string, IconPosition> Items { get; set; } = new();
    }

    private IconLayout _layout = new IconLayout();

        private readonly Dictionary<FrameworkElement, Point> _dragStartPositions = new();

    private readonly List<FrameworkElement> _selectedIcons = new();

    private bool _isSelecting;
    private Point _selectionStart;
    private Rectangle? _selectionRectangle;

    private sealed class TaskbarInstance
    {
        public Rect MonitorRect { get; set; }
        public Border Host { get; set; } = null!;
        public StackPanel WindowPanel { get; set; } = null!;
        public TextBlock ClockText { get; set; } = null!;
        public Button StartButton { get; set; } = null!;
    }

    private readonly List<TaskbarInstance> _taskbars = new();

    private readonly DispatcherTimer _clockTimer = new();
    private readonly DispatcherTimer _taskbarTimer = new();

        private delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);

    [DllImport("user32.dll")]
    private static extern bool EnumWindows(EnumWindowsProc lpEnumFunc, IntPtr lParam);

    [DllImport("user32.dll")]
    private static extern bool IsWindowVisible(IntPtr hWnd);

    [DllImport("user32.dll", CharSet = CharSet.Unicode)]
    private static extern int GetWindowText(IntPtr hWnd, StringBuilder lpString, int nMaxCount);

    [DllImport("user32.dll", CharSet = CharSet.Unicode)]
    private static extern int GetWindowTextLength(IntPtr hWnd);

    [DllImport("user32.dll")]
    private static extern IntPtr GetShellWindow();

    [DllImport("user32.dll")]
    private static extern IntPtr GetAncestor(IntPtr hWnd, uint gaFlags);

    [DllImport("user32.dll")]
    private static extern bool SetForegroundWindow(IntPtr hWnd);

    [DllImport("user32.dll")]
    private static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

    [DllImport("user32.dll")]
    private static extern bool IsIconic(IntPtr hWnd);

    private const uint GA_ROOTOWNER = 3;
    private const int SW_RESTORE = 9;

    private sealed class TaskbarWindowItem
    {
        public IntPtr Hwnd { get; set; }
        public string Title { get; set; } = string.Empty;
        public Rect Bounds { get; set; }
    }


    private const int SPI_GETDESKWALLPAPER = 0x0073;

    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    private static extern bool SystemParametersInfo(
        int uAction,
        int uParam,
        StringBuilder lpvParam,
        int fuWinIni);

    [StructLayout(LayoutKind.Sequential)]
    private struct MONITORRECT
    {
        public int Left;
        public int Top;
        public int Right;
        public int Bottom;
    }

    private delegate bool MonitorEnumProc(
        IntPtr hMonitor,
        IntPtr hdcMonitor,
        ref MONITORRECT lprcMonitor,
        IntPtr dwData);

    [DllImport("user32.dll", SetLastError = true)]
    private static extern bool EnumDisplayMonitors(
        IntPtr hdc,
        IntPtr lprcClip,
        MonitorEnumProc lpfnEnum,
        IntPtr dwData);

    private bool _isDragging;
    private Point _dragStartMouse;
    private Point _dragStartElement;
    private FrameworkElement? _dragElement;

    [DllImport("user32.dll", SetLastError = true)]
    private static extern IntPtr FindWindow(string lpClassName, string? lpWindowName);

    private const int SW_HIDE = 0;
    private const int SW_SHOW = 5;
    private IntPtr _taskbarHandle = IntPtr.Zero;

    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
    private static extern IntPtr FindWindowEx(
    IntPtr hWndParent,
    IntPtr hWndChildAfter,
    string lpszClass,
    string? lpszWindow);

    [StructLayout(LayoutKind.Sequential)]
    private struct RECT
    {
        public int left;
        public int top;
        public int right;
        public int bottom;
    }

    [StructLayout(LayoutKind.Sequential)]
    private struct MONITORINFO2
    {
        public int cbSize;
        public RECT rcMonitor;         public RECT rcWork;            public uint dwFlags;
    }

    [DllImport("user32.dll", SetLastError = true)]
    private static extern bool GetMonitorInfo(IntPtr hMonitor, ref MONITORINFO2 lpmi);

    [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool SystemParametersInfo(
        int uiAction,
        int uiParam,
        ref RECT pvParam,
        int fWinIni);

    private const int SPI_SETWORKAREA = 0x002F;
    private const int SPIF_SENDCHANGE = 0x0002;

    private sealed class WorkAreaBackup
    {
        public IntPtr MonitorHandle;
        public RECT OriginalWorkArea;
    }

    private readonly List<WorkAreaBackup> _workAreaBackups = new();

    public MainWindow()
    {
        InitializeComponent();
        Loaded += MainWindow_Loaded;
        Closed += MainWindow_Closed;

        IconCanvas.MouseMove += IconCanvas_MouseMove;
        IconCanvas.MouseLeftButtonUp += IconCanvas_MouseLeftButtonUp;
        IconCanvas.MouseLeftButtonUp += IconCanvas_MouseLeftButtonUp;
        IconCanvas.MouseLeftButtonDown += IconCanvas_MouseLeftButtonDown;
    }

    private static IEnumerable<IntPtr> EnumerateTaskbarWindows()
    {
                IntPtr primary = FindWindow("Shell_TrayWnd", null);
        if (primary != IntPtr.Zero)
            yield return primary;

                IntPtr child = IntPtr.Zero;
        while (true)
        {
            child = FindWindowEx(IntPtr.Zero, child, "Shell_SecondaryTrayWnd", null);
            if (child == IntPtr.Zero)
                break;

            yield return child;
        }
    }

    private void HideTaskbarWindow()
    {
        foreach (var h in EnumerateTaskbarWindows())
        {
            ShowWindow(h, SW_HIDE);
        }
    }

    private void ShowTaskbarWindow()
    {
        foreach (var h in EnumerateTaskbarWindows())
        {
            ShowWindow(h, SW_SHOW);
        }
    }

    private static void RestartExplorerShell()
    {
        try
        {
                        foreach (var p in Process.GetProcessesByName("explorer"))
            {
                try { p.Kill(); }
                catch { }
            }

                        System.Threading.Thread.Sleep(500);

                        Process.Start(new ProcessStartInfo("explorer.exe")
            {
                UseShellExecute = true
            });
        }
        catch (Exception ex)
        {
            Debug.WriteLine("RestartExplorerShell failed: " + ex);
        }
    }

    private static List<Rect> GetMonitorRects()
    {
        var list = new List<Rect>();

        MonitorEnumProc callback = (IntPtr hMon, IntPtr hdc, ref MONITORRECT rc, IntPtr data) =>
        {
            double x = rc.Left;
            double y = rc.Top;
            double w = rc.Right - rc.Left;
            double h = rc.Bottom - rc.Top;

            list.Add(new Rect(x, y, w, h));
            return true;         };

        EnumDisplayMonitors(IntPtr.Zero, IntPtr.Zero, callback, IntPtr.Zero);
        return list;
    }

    private void BuildTaskbars()
    {
        TaskbarCanvas.Children.Clear();
        _taskbars.Clear();

        double vLeft = SystemParameters.VirtualScreenLeft;
        double vTop = SystemParameters.VirtualScreenTop;

        var monitors = GetMonitorRects();

        foreach (var m in monitors)
        {
            double barHeight = 48;
            double marginX = 48;
            double marginBottom = 16;
            double barWidth = Math.Min(600, m.Width - marginX * 2);

            var host = new Border
            {
                Width = barWidth,
                Height = barHeight,
                CornerRadius = new CornerRadius(24),
                Background = new SolidColorBrush(Color.FromArgb(0xCC, 0x20, 0x20, 0x20)),
                SnapsToDevicePixels = true,
                Effect = new DropShadowEffect
                {
                    BlurRadius = 12,
                    Opacity = 0.4,
                    ShadowDepth = 0
                }
            };

            var grid = new Grid();
            grid.ColumnDefinitions.Add(new ColumnDefinition { Width = new GridLength(1, GridUnitType.Star) });
            grid.ColumnDefinitions.Add(new ColumnDefinition { Width = GridLength.Auto });
            grid.ColumnDefinitions.Add(new ColumnDefinition { Width = new GridLength(1, GridUnitType.Star) });
            host.Child = grid;

                        var centerPanel = new StackPanel
            {
                Orientation = Orientation.Horizontal,
                HorizontalAlignment = HorizontalAlignment.Center,
                VerticalAlignment = VerticalAlignment.Center
            };
            Grid.SetColumn(centerPanel, 1);
            grid.Children.Add(centerPanel);

            var startButton = new Button
            {
                Style = (Style)FindResource("TaskbarButtonStyle")
            };
            startButton.Content = new TextBlock
            {
                Text = "⊞",
                FontSize = 18,
                Foreground = Brushes.White,
                Margin = new Thickness(0, -1, 0, 0),
                TextAlignment = TextAlignment.Center
            };
            centerPanel.Children.Add(startButton);

            var windowPanel = new StackPanel
            {
                Orientation = Orientation.Horizontal,
                VerticalAlignment = VerticalAlignment.Center,
                Margin = new Thickness(8, 0, 0, 0)
            };
            centerPanel.Children.Add(windowPanel);

                        var rightPanel = new StackPanel
            {
                Orientation = Orientation.Horizontal,
                HorizontalAlignment = HorizontalAlignment.Right,
                VerticalAlignment = VerticalAlignment.Center,
                Margin = new Thickness(0, 0, 16, 0)
            };
            Grid.SetColumn(rightPanel, 2);
            grid.Children.Add(rightPanel);

            var clockText = new TextBlock
            {
                Foreground = Brushes.White,
                FontWeight = FontWeights.SemiBold,
                VerticalAlignment = VerticalAlignment.Center
            };
            rightPanel.Children.Add(clockText);

                        double left = (m.X - vLeft) + (m.Width - barWidth) / 2.0;
            double top = (m.Y - vTop) + (m.Height - barHeight - marginBottom);

            Canvas.SetLeft(host, left);
            Canvas.SetTop(host, top);
            TaskbarCanvas.Children.Add(host);

                        startButton.Click += (s, e) =>
            {
                try
                {
                    Process.Start(new ProcessStartInfo("explorer.exe") { UseShellExecute = true });
                }
                catch { }
            };

            _taskbars.Add(new TaskbarInstance
            {
                MonitorRect = m,
                Host = host,
                WindowPanel = windowPanel,
                ClockText = clockText,
                StartButton = startButton
            });
        }
    }

    private void LoadWallpaper()
    {
        try
        {
            var sb = new StringBuilder(260);
            if (!SystemParametersInfo(SPI_GETDESKWALLPAPER, sb.Capacity, sb, 0))
                return;

            var path = sb.ToString();
            if (string.IsNullOrWhiteSpace(path) || !File.Exists(path))
                return;

                        var bitmap = new BitmapImage(new Uri(path));
            bitmap.Freeze();

            WallpaperCanvas.Children.Clear();

                        double vLeft = SystemParameters.VirtualScreenLeft;
            double vTop = SystemParameters.VirtualScreenTop;

            var monitors = GetMonitorRects();
            foreach (var m in monitors)
            {
                var img = new Image
                {
                    Source = bitmap,
                    Stretch = Stretch.UniformToFill,
                    Width = m.Width,
                    Height = m.Height
                };

                                double x = m.X - vLeft;
                double y = m.Y - vTop;

                Canvas.SetLeft(img, x);
                Canvas.SetTop(img, y);

                WallpaperCanvas.Children.Add(img);
            }
        }
        catch
        {
                    }
    }

    private void MainWindow_Loaded(object sender, RoutedEventArgs e)
    {
        Left = SystemParameters.VirtualScreenLeft;
        Top = SystemParameters.VirtualScreenTop;
        Width = SystemParameters.VirtualScreenWidth;
        Height = SystemParameters.VirtualScreenHeight;

        LoadWallpaper();
        LoadLayout();
        RenderDesktopIcons();

        InitClock();
        InitTaskbar();

        HideTaskbarWindow();
    }

    private void MainWindow_Closed(object? sender, EventArgs e)
    {
        ShowTaskbarWindow();
    }

    private void InitClock()
    {
        _clockTimer.Interval = TimeSpan.FromSeconds(1);
        _clockTimer.Tick += (s, e) =>
        {
            string time = DateTime.Now.ToString("HH:mm");
            foreach (var bar in _taskbars)
            {
                bar.ClockText.Text = time;
            }
        };
        _clockTimer.Start();
    }


    private void InitTaskbar()
    {
        BuildTaskbars();

        _taskbarTimer.Interval = TimeSpan.FromSeconds(2);
        _taskbarTimer.Tick += (s, e) => RefreshTaskbarWindows();
        _taskbarTimer.Start();

        RefreshTaskbarWindows();
    }

    private void RefreshTaskbarWindows()
    {
        var selfHandle = new WindowInteropHelper(this).Handle;
        var shell = GetShellWindow();

        var windows = new List<TaskbarWindowItem>();

        EnumWindows((hWnd, lParam) =>
        {
            if (hWnd == shell || hWnd == selfHandle)
                return true;

            if (!IsWindowVisible(hWnd))
                return true;

            IntPtr root = GetAncestor(hWnd, GA_ROOTOWNER);
            if (root != hWnd)
                return true;

            int len = GetWindowTextLength(hWnd);
            if (len == 0)
                return true;

            var sb = new StringBuilder(len + 1);
            GetWindowText(hWnd, sb, sb.Capacity);
            string title = sb.ToString();
            if (string.IsNullOrWhiteSpace(title))
                return true;

            if (!DesktopShellReader.GetWindowRect(hWnd, out var rc))
                return true;

            var bounds = new Rect(rc.Left, rc.Top, rc.Right - rc.Left, rc.Bottom - rc.Top);

            windows.Add(new TaskbarWindowItem
            {
                Hwnd = hWnd,
                Title = title,
                Bounds = bounds
            });

            return true;
        }, IntPtr.Zero);

                foreach (var bar in _taskbars)
        {
            bar.WindowPanel.Children.Clear();

            foreach (var w in windows)
            {
                var iconSource = GetWindowIconFromExe(w.Hwnd);

                FrameworkElement content;
                if (iconSource != null)
                {
                    content = new Image
                    {
                        Source = iconSource,
                        Width = 24,
                        Height = 24
                    };
                }
                else
                {
                    content = new TextBlock
                    {
                        Text = "■",
                        Foreground = Brushes.White,
                        FontSize = 14
                    };
                }

                var btn = new Button
                {
                    Style = (Style)FindResource("TaskbarButtonStyle"),
                    Tag = w.Hwnd,
                    ToolTip = w.Title,
                    Content = content
                };

                btn.Click += TaskbarWindowButton_Click;
                bar.WindowPanel.Children.Add(btn);
            }
        }
    }

    [DllImport("user32.dll", SetLastError = true)]
    private static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint lpdwProcessId);

    private static ImageSource? GetWindowIconFromExe(IntPtr hWnd)
    {
        try
        {
            GetWindowThreadProcessId(hWnd, out uint pid);
            if (pid == 0) return null;

            using var proc = Process.GetProcessById((int)pid);
            string? exe = proc.MainModule?.FileName;
            if (string.IsNullOrEmpty(exe))
                return null;

                        return ShellIcon.GetFileIconSource(exe, small: false);
        }
        catch
        {
            return null;
        }
    }

    private void TaskbarWindowButton_Click(object sender, RoutedEventArgs e)
    {
        if (sender is Button btn && btn.Tag is IntPtr hwnd && hwnd != IntPtr.Zero)
        {
            try
            {
                if (IsIconic(hwnd))
                {
                    ShowWindow(hwnd, SW_RESTORE);
                }

                SetForegroundWindow(hwnd);
            }
            catch { }
        }
    }


    private void LoadLayout()
    {
        try
        {
            var dir = Path.GetDirectoryName(_layoutFile)!;
            if (!Directory.Exists(dir))
                Directory.CreateDirectory(dir);

            if (File.Exists(_layoutFile))
            {
                var json = File.ReadAllText(_layoutFile);
                _layout = JsonSerializer.Deserialize<IconLayout>(json) ?? new IconLayout();
            }
        }
        catch
        {
            _layout = new IconLayout();
        }
    }

    private void SaveLayout()
    {
        try
        {
            var dir = Path.GetDirectoryName(_layoutFile)!;
            if (!Directory.Exists(dir))
                Directory.CreateDirectory(dir);

            var json = JsonSerializer.Serialize(_layout, new JsonSerializerOptions
            {
                WriteIndented = true
            });
            File.WriteAllText(_layoutFile, json);
        }
        catch { }
    }

    private void SelectIcon(FrameworkElement fe)
    {
        if (_selectedIcons.Contains(fe)) return;
        _selectedIcons.Add(fe);
        SetIconSelectedVisual(fe, true);
    }

    private void UnselectIcon(FrameworkElement fe)
    {
        if (!_selectedIcons.Remove(fe)) return;
        SetIconSelectedVisual(fe, false);
    }

    private void ClearSelection()
    {
        foreach (var fe in _selectedIcons)
            SetIconSelectedVisual(fe, false);

        _selectedIcons.Clear();
    }

    private void SetIconSelectedVisual(FrameworkElement fe, bool isSelected)
    {
        if (fe is StackPanel sp)
        {
            sp.Background = isSelected
                ? new SolidColorBrush(System.Windows.Media.Color.FromArgb(80, 0, 120, 215))
                : Brushes.Transparent;
        }
    }

    private void UpdateSelectionRectangle(Rect selection)
    {
        foreach (UIElement child in IconCanvas.Children)
        {
            if (child is StackPanel sp && sp.Tag is string)
            {
                double left = Canvas.GetLeft(sp);
                double top = Canvas.GetTop(sp);
                if (double.IsNaN(left)) left = 0;
                if (double.IsNaN(top)) top = 0;

                double width = sp.ActualWidth > 0 ? sp.ActualWidth : 90;
                double height = sp.ActualHeight > 0 ? sp.ActualHeight : 80;

                var bounds = new Rect(left, top, width, height);
                bool intersects = selection.IntersectsWith(bounds);

                if (intersects)
                    SelectIcon(sp);
                else
                    UnselectIcon(sp);
            }
        }
    }

    private void SaveCurrentSelectionPositions()
    {
                if (_selectedIcons.Count == 0 && _dragElement != null)
        {
            _selectedIcons.Add(_dragElement);
        }

        foreach (var fe in _selectedIcons)
        {
            if (fe.Tag is string id)
            {
                double left = Canvas.GetLeft(fe);
                double top = Canvas.GetTop(fe);
                if (double.IsNaN(left)) left = 0;
                if (double.IsNaN(top)) top = 0;

                _layout.Items[id] = new IconPosition { X = left, Y = top };
            }
        }

        SaveLayout();
    }

    private void RenderDesktopIcons()
    {
        IconCanvas.Children.Clear();

                var icons = DesktopShellReader.GetDesktopIcons();

                var nameToPath = BuildDesktopFileMap();

        double virtualLeft = SystemParameters.VirtualScreenLeft;
        double virtualTop = SystemParameters.VirtualScreenTop;

        foreach (var icon in icons)
        {
            string? launchArg = null;
            ImageSource? imageSource = null;
            string displayText = icon.Name;

                        if (nameToPath.TryGetValue(icon.Name, out string fullPath))
            {
                imageSource = ShellIcon.GetFileIconSource(fullPath, small: false);
                if (imageSource == null)
                    continue;

                launchArg = fullPath;
            }
                        else if (ShellSpecialItems.TryResolve(icon.Name, out var specialKind))
            {
                imageSource = ShellSpecialItems.GetIcon(specialKind, small: false);
                if (imageSource == null)
                    continue;

                launchArg = ShellSpecialItems.GetExplorerArgument(specialKind);
            }
            else
            {
                                continue;
            }

            var img = new Image
            {
                Source = imageSource,
                Width = 48,
                Height = 48
            };

            var text = new TextBlock
            {
                Text = displayText,
                Foreground = Brushes.White,
                TextAlignment = TextAlignment.Center,
                TextWrapping = TextWrapping.Wrap,
                Width = 90
            };

            text.LineStackingStrategy = LineStackingStrategy.BlockLineHeight;
            text.LineHeight = text.FontSize * 1.2;                  text.MaxHeight = text.LineHeight * 2;       
            var stack = new StackPanel
            {
                Orientation = Orientation.Vertical,
                Tag = launchArg,                  Width = 90,
                ClipToBounds = true
            };

            stack.Children.Add(img);
            stack.Children.Add(text);
            stack.MouseLeftButtonDown += Icon_MouseLeftButtonDown;
            AttachContextMenu(stack, launchArg);

            double canvasX = icon.ScreenPosition.X - virtualLeft;
            double canvasY = icon.ScreenPosition.Y - virtualTop;

            if (!string.IsNullOrEmpty(launchArg) &&
            _layout.Items.TryGetValue(launchArg, out var saved))
            {
                canvasX = saved.X;
                canvasY = saved.Y;
            }

            Canvas.SetLeft(stack, canvasX);
            Canvas.SetTop(stack, canvasY);

            IconCanvas.Children.Add(stack);
        }

                if (IconCanvas.Children.Count == 0)
        {
            RenderSimpleGridDesktop();
        }
    }
    private void RenderSimpleGridDesktop()
    {
        const int IconSize = 48;
        const int IconSpacingX = 100;
        const int IconSpacingY = 90;
        const int MarginLeft = 30;
        const int MarginTop = 30;

        double x = MarginLeft;
        double y = MarginTop;
        double maxHeight = Height;

        var nameToPath = BuildDesktopFileMap();

        foreach (var kv in nameToPath)
        {
            string name = kv.Key;
            string path = kv.Value;

            var imageSource = ShellIcon.GetFileIconSource(path, small: false);
            if (imageSource == null)
                continue;

            var img = new Image
            {
                Source = imageSource,
                Width = IconSize,
                Height = IconSize
            };

            var text = new TextBlock
            {
                Text = Path.GetFileNameWithoutExtension(path),
                Foreground = Brushes.White,
                TextAlignment = TextAlignment.Center,
                TextWrapping = TextWrapping.Wrap,
                Width = IconSpacingX
            };

            var stack = new StackPanel
            {
                Orientation = Orientation.Vertical,
                Tag = path,
                Width = IconSpacingX
            };

            stack.Children.Add(img);
            stack.Children.Add(text);
            stack.MouseLeftButtonDown += Icon_MouseLeftButtonDown;

            Canvas.SetLeft(stack, x);
            Canvas.SetTop(stack, y);
            IconCanvas.Children.Add(stack);

            y += IconSpacingY;
            if (y + IconSpacingY > maxHeight - MarginTop)
            {
                y = MarginTop;
                x += IconSpacingX;
            }
        }
    }

    private Dictionary<string, string> BuildDesktopFileMap()
    {
        var map = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

        string[] roots =
        {
        Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory),
        Environment.GetFolderPath(Environment.SpecialFolder.CommonDesktopDirectory)
    };

        foreach (var root in roots)
        {
            if (string.IsNullOrEmpty(root) || !Directory.Exists(root))
                continue;

            foreach (var entry in Directory.EnumerateFileSystemEntries(root, "*", SearchOption.TopDirectoryOnly))
            {
                string fileName = Path.GetFileName(entry);                                 if (string.IsNullOrEmpty(fileName))
                    continue;

                string nameWithoutExt = Path.GetFileNameWithoutExtension(entry); 
                                if (!map.ContainsKey(fileName))
                    map[fileName] = entry;

                                if (!string.IsNullOrEmpty(nameWithoutExt) && !map.ContainsKey(nameWithoutExt))
                    map[nameWithoutExt] = entry;
            }
        }

        return map;
    }

    private void DeleteItem(string arg)
    {
        try
        {
                        if (!(File.Exists(arg) || Directory.Exists(arg)))
                return;

            var result = MessageBox.Show(
                $"Delete '{System.IO.Path.GetFileName(arg)}'?",
                "Confirm Delete",
                MessageBoxButton.YesNo,
                MessageBoxImage.Warning);

            if (result != MessageBoxResult.Yes)
                return;

            if (File.Exists(arg))
            {
                File.Delete(arg);
            }
            else if (Directory.Exists(arg))
            {
                Directory.Delete(arg, true);
            }

                        RenderDesktopIcons();
        }
        catch (Exception ex)
        {
            MessageBox.Show(
                $"Failed to delete:\n{ex.Message}",
                "Error",
                MessageBoxButton.OK,
                MessageBoxImage.Error);
        }
    }

    private void ShowInExplorer(string arg)
    {
        try
        {
            if (File.Exists(arg) || Directory.Exists(arg))
            {
                var psi = new ProcessStartInfo("explorer.exe", $"/select,\"{arg}\"")
                {
                    UseShellExecute = true
                };
                Process.Start(psi);
            }
            else
            {
                                var psi = new ProcessStartInfo("explorer.exe", arg)
                {
                    UseShellExecute = true
                };
                Process.Start(psi);
            }
        }
        catch (Exception ex)
        {
            MessageBox.Show(
                $"Failed to open Explorer:\n{ex.Message}",
                "Error",
                MessageBoxButton.OK,
                MessageBoxImage.Error);
        }
    }

    private void Icon_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
    {
        if (sender is FrameworkElement fe)
        {
                        if (e.ClickCount == 2 && fe.Tag is string arg)
            {
                OpenItem(arg);
                return;
            }

                        if ((Keyboard.Modifiers & ModifierKeys.Control) == ModifierKeys.Control)
            {
                if (_selectedIcons.Contains(fe))
                    UnselectIcon(fe);
                else
                    SelectIcon(fe);
                return;
            }

                        if (!_selectedIcons.Contains(fe))
            {
                ClearSelection();
                SelectIcon(fe);
            }

                        _dragElement = fe;
            _isDragging = true;
            _dragStartMouse = e.GetPosition(IconCanvas);

            _dragStartPositions.Clear();
            foreach (var icon in _selectedIcons)
            {
                double left = Canvas.GetLeft(icon);
                double top = Canvas.GetTop(icon);
                if (double.IsNaN(left)) left = 0;
                if (double.IsNaN(top)) top = 0;
                _dragStartPositions[icon] = new Point(left, top);
            }

            IconCanvas.CaptureMouse();
            e.Handled = true;
        }
    }
    private void IconCanvas_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
    {
                if (e.Source == IconCanvas)
        {
            ClearSelection();

            _isSelecting = true;
            _selectionStart = e.GetPosition(IconCanvas);

            if (_selectionRectangle == null)
            {
                _selectionRectangle = new Rectangle
                {
                    Stroke = Brushes.LightBlue,
                    StrokeThickness = 1,
                    Fill = new SolidColorBrush(Color.FromArgb(60, 0, 120, 215)),
                    IsHitTestVisible = false
                };
            }

            if (!IconCanvas.Children.Contains(_selectionRectangle))
                IconCanvas.Children.Add(_selectionRectangle);

            Canvas.SetLeft(_selectionRectangle, _selectionStart.X);
            Canvas.SetTop(_selectionRectangle, _selectionStart.Y);
            _selectionRectangle.Width = 0;
            _selectionRectangle.Height = 0;

            IconCanvas.CaptureMouse();
            e.Handled = true;
        }
    }
    private void AttachContextMenu(StackPanel stack, string launchArg)
    {
        var menu = new ContextMenu();

        var open = new MenuItem { Header = "Open" };
        open.Click += (s, e) =>
        {
            OpenItem(launchArg);
        };

        var delete = new MenuItem { Header = "Delete" };
        delete.Click += (s, e) =>
        {
            DeleteItem(launchArg);
        };

        var show = new MenuItem { Header = "Show in Explorer" };
        show.Click += (s, e) =>
        {
            ShowInExplorer(launchArg);
        };

        menu.Items.Add(open);
        menu.Items.Add(delete);
        menu.Items.Add(new Separator());
        menu.Items.Add(show);

        stack.ContextMenu = menu;
    }

    private void IconCanvas_MouseMove(object sender, MouseEventArgs e)
    {
        if (_isDragging && _dragElement != null)
        {
            var pos = e.GetPosition(IconCanvas);
            double dx = pos.X - _dragStartMouse.X;
            double dy = pos.Y - _dragStartMouse.Y;

            foreach (var kvp in _dragStartPositions)
            {
                var el = kvp.Key;
                var start = kvp.Value;

                double newX = start.X + dx;
                double newY = start.Y + dy;

                if (newX < 0) newX = 0;
                if (newY < 0) newY = 0;

                Canvas.SetLeft(el, newX);
                Canvas.SetTop(el, newY);
            }
        }
        else if (_isSelecting && _selectionRectangle != null)
        {
            var pos = e.GetPosition(IconCanvas);

            double x = Math.Min(pos.X, _selectionStart.X);
            double y = Math.Min(pos.Y, _selectionStart.Y);
            double w = Math.Abs(pos.X - _selectionStart.X);
            double h = Math.Abs(pos.Y - _selectionStart.Y);

            Canvas.SetLeft(_selectionRectangle, x);
            Canvas.SetTop(_selectionRectangle, y);
            _selectionRectangle.Width = w;
            _selectionRectangle.Height = h;

            UpdateSelectionRectangle(new Rect(x, y, w, h));
        }
    }

    private void IconCanvas_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
    {
        if (_isDragging)
        {
            _isDragging = false;
            IconCanvas.ReleaseMouseCapture();

                        SaveCurrentSelectionPositions();

            _dragStartPositions.Clear();
            _dragElement = null;
        }
        else if (_isSelecting)
        {
            _isSelecting = false;
            IconCanvas.ReleaseMouseCapture();

            if (_selectionRectangle != null && IconCanvas.Children.Contains(_selectionRectangle))
            {
                IconCanvas.Children.Remove(_selectionRectangle);
            }
        }
    }

    private void OpenItem(string arg)
    {
        try
        {
            if (string.IsNullOrEmpty(arg))
                return;

                        if (File.Exists(arg) || Directory.Exists(arg))
            {
                var psi = new ProcessStartInfo(arg)
                {
                    UseShellExecute = true
                };
                Process.Start(psi);
            }
            else
            {
                                var psi = new ProcessStartInfo("explorer.exe", arg)
                {
                    UseShellExecute = true
                };
                Process.Start(psi);
            }
        }
        catch (Exception ex)
        {
            MessageBox.Show(
                $"Failed to open item:\n{ex.Message}",
                "Error",
                MessageBoxButton.OK,
                MessageBoxImage.Error);
        }
    }
}

public sealed class DesktopIconInfo
{
    public string Name { get; set; } = string.Empty;            public Point ScreenPosition { get; set; }               }

public static class DesktopShellReader
{
        private const int LVM_FIRST = 0x1000;
    private const int LVM_GETITEMCOUNT = LVM_FIRST + 4;
    private const int LVM_GETITEMPOSITION = LVM_FIRST + 16;
    private const int LVM_GETITEMTEXTW = LVM_FIRST + 115;

    private const uint LVIF_TEXT = 0x0001;

        private const uint PROCESS_VM_OPERATION = 0x0008;
    private const uint PROCESS_VM_READ = 0x0010;
    private const uint PROCESS_VM_WRITE = 0x0020;
    private const uint PROCESS_QUERY_INFORMATION = 0x0400;

    private const uint MEM_COMMIT = 0x1000;
    private const uint MEM_RESERVE = 0x2000;
    private const uint MEM_RELEASE = 0x8000;
    private const uint PAGE_READWRITE = 0x04;

    
    [StructLayout(LayoutKind.Sequential)]
    private struct POINT
    {
        public int X;
        public int Y;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct RECT
    {
        public int Left;
        public int Top;
        public int Right;
        public int Bottom;
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    private struct LVITEM
    {
        public uint mask;
        public int iItem;
        public int iSubItem;
        public uint state;
        public uint stateMask;
        public IntPtr pszText;
        public int cchTextMax;
        public int iImage;
        public IntPtr lParam;
        public int iIndent;
        public int iGroupId;
        public uint cColumns;
        public IntPtr puColumns;
        public IntPtr piColFmt;
        public int iGroup;
    }

    
    private delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);

    [DllImport("user32.dll")]
    private static extern IntPtr GetShellWindow();

    [DllImport("user32.dll", SetLastError = true)]
    private static extern bool EnumWindows(EnumWindowsProc lpEnumFunc, IntPtr lParam);

    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
    private static extern IntPtr FindWindowEx(
        IntPtr parentHandle,
        IntPtr childAfter,
        string lpszClass,
        string? lpszWindow);

    [DllImport("user32.dll", SetLastError = true)]
    private static extern uint GetWindowThreadProcessId(
        IntPtr hWnd,
        out uint lpdwProcessId);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);

    [DllImport("user32.dll", CharSet = CharSet.Unicode)]
    private static extern IntPtr SendMessage(
        IntPtr hWnd,
        uint Msg,
        IntPtr wParam,
        IntPtr lParam);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr OpenProcess(
        uint dwDesiredAccess,
        bool bInheritHandle,
        uint dwProcessId);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool CloseHandle(IntPtr hObject);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr VirtualAllocEx(
        IntPtr hProcess,
        IntPtr lpAddress,
        uint dwSize,
        uint flAllocationType,
        uint flProtect);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool VirtualFreeEx(
        IntPtr hProcess,
        IntPtr lpAddress,
        uint dwSize,
        uint dwFreeType);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool ReadProcessMemory(
        IntPtr hProcess,
        IntPtr lpBaseAddress,
        [Out] byte[] lpBuffer,
        uint dwSize,
        out UIntPtr lpNumberOfBytesRead);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool WriteProcessMemory(
        IntPtr hProcess,
        IntPtr lpBaseAddress,
        byte[] lpBuffer,
        uint nSize,
        out UIntPtr lpNumberOfBytesWritten);

    
    private static IntPtr Add(IntPtr ptr, int offset)
    {
        if (IntPtr.Size == 8)
            return new IntPtr(ptr.ToInt64() + offset);
        return new IntPtr(ptr.ToInt32() + offset);
    }

                    private static IntPtr GetDesktopListViewHandle()
    {
        IntPtr shellWindow = GetShellWindow();
        IntPtr defView = FindWindowEx(shellWindow, IntPtr.Zero, "SHELLDLL_DefView", null);
        IntPtr listView = IntPtr.Zero;

        if (defView != IntPtr.Zero)
        {
            listView = FindWindowEx(defView, IntPtr.Zero, "SysListView32", "FolderView");
        }

        if (listView != IntPtr.Zero)
            return listView;

                EnumWindows((hwnd, _) =>
        {
            IntPtr child = FindWindowEx(hwnd, IntPtr.Zero, "SHELLDLL_DefView", null);
            if (child != IntPtr.Zero)
            {
                defView = child;
                listView = FindWindowEx(child, IntPtr.Zero, "SysListView32", "FolderView");
                return false;             }
            return true;
        }, IntPtr.Zero);

        return listView;
    }

                public static List<DesktopIconInfo> GetDesktopIcons()
    {
        var result = new List<DesktopIconInfo>();

        IntPtr listView = GetDesktopListViewHandle();
        if (listView == IntPtr.Zero)
            return result;

                int iconCount = (int)SendMessage(listView, LVM_GETITEMCOUNT, IntPtr.Zero, IntPtr.Zero);
        if (iconCount <= 0)
            return result;

                GetWindowThreadProcessId(listView, out uint processId);
        IntPtr hProcess = OpenProcess(
            PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION,
            false,
            processId);

        if (hProcess == IntPtr.Zero)
            return result;

        RECT lvRect;
        GetWindowRect(listView, out lvRect);
        double originX = lvRect.Left;
        double originY = lvRect.Top;

        try
        {
                        uint pointSize = (uint)Marshal.SizeOf(typeof(POINT));
            IntPtr remotePoint = VirtualAllocEx(hProcess, IntPtr.Zero, pointSize,
                MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
            if (remotePoint == IntPtr.Zero)
                return result;

                        const int maxTextChars = 260;
            uint lvItemSize = (uint)Marshal.SizeOf(typeof(LVITEM));
            uint textBufferSize = (uint)(maxTextChars * 2);             uint totalSize = lvItemSize + textBufferSize;

            IntPtr remoteBuffer = VirtualAllocEx(hProcess, IntPtr.Zero, totalSize,
                MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
            if (remoteBuffer == IntPtr.Zero)
            {
                VirtualFreeEx(hProcess, remotePoint, 0, MEM_RELEASE);
                return result;
            }

            var lvItem = new LVITEM
            {
                mask = LVIF_TEXT,
                iSubItem = 0,
                pszText = Add(remoteBuffer, (int)lvItemSize),
                cchTextMax = maxTextChars
            };

            byte[] lvItemBytes = new byte[lvItemSize];
            byte[] textBytes = new byte[textBufferSize];
            byte[] pointBytes = new byte[pointSize];

            IntPtr lvItemLocalPtr = Marshal.AllocHGlobal((int)lvItemSize);
            IntPtr pointLocalPtr = Marshal.AllocHGlobal((int)pointSize);

            try
            {
                for (int i = 0; i < iconCount; i++)
                {
                    lvItem.iItem = i;

                                        Marshal.StructureToPtr(lvItem, lvItemLocalPtr, false);
                    Marshal.Copy(lvItemLocalPtr, lvItemBytes, 0, (int)lvItemSize);

                    UIntPtr bytesWritten;
                    WriteProcessMemory(hProcess, remoteBuffer, lvItemBytes, lvItemSize, out bytesWritten);

                                        SendMessage(listView, LVM_GETITEMTEXTW, new IntPtr(i), remoteBuffer);

                    UIntPtr bytesRead;
                    ReadProcessMemory(hProcess, Add(remoteBuffer, (int)lvItemSize),
                        textBytes, textBufferSize, out bytesRead);

                    string label = Encoding.Unicode.GetString(textBytes);
                    int end = label.IndexOf('\0');
                    if (end >= 0) label = label.Substring(0, end);

                    if (string.IsNullOrWhiteSpace(label))
                        continue;

                                        SendMessage(listView, LVM_GETITEMPOSITION, new IntPtr(i), remotePoint);
                    ReadProcessMemory(hProcess, remotePoint, pointBytes, pointSize, out bytesRead);

                    Marshal.Copy(pointBytes, 0, pointLocalPtr, (int)pointSize);
                    var pt = Marshal.PtrToStructure<POINT>(pointLocalPtr);

                                        double screenX = originX + pt.X;
                    double screenY = originY + pt.Y;

                    result.Add(new DesktopIconInfo
                    {
                        Name = label,
                        ScreenPosition = new Point(screenX, screenY)
                    });
                }
            }
            finally
            {
                Marshal.FreeHGlobal(lvItemLocalPtr);
                Marshal.FreeHGlobal(pointLocalPtr);

                VirtualFreeEx(hProcess, remoteBuffer, 0, MEM_RELEASE);
                VirtualFreeEx(hProcess, remotePoint, 0, MEM_RELEASE);
            }
        }
        finally
        {
            CloseHandle(hProcess);
        }

        return result;
    }
}